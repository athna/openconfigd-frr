// Generated by pyang using OpenConfig https://github.com/openconfig/public.
//
// Copyright 2016 OpenConfigd Project.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

//struct for container coreswitch:ospf
type OspfIp struct {
	// original -> coreswitch:authentication-key
	AuthenticationKey string `mapstructure:"authentication-key" json:"authentication-key,omitempty"`
	// original -> coreswitch:cost
	Cost uint16 `mapstructure:"cost" json:"cost,omitempty"`
	// original -> coreswitch:dead-interval
	DeadInterval uint16 `mapstructure:"dead-interval" json:"dead-interval,omitempty"`
	// original -> coreswitch:hello-interval
	HelloInterval uint16 `mapstructure:"hello-interval" json:"hello-interval,omitempty"`
	// original -> coreswitch:priority
	Priority string `mapstructure:"priority" json:"priority,omitempty"`
	// original -> coreswitch:retransmit-interval
	RetransmitInterval uint16 `mapstructure:"retransmit-interval" json:"retransmit-interval,omitempty"`
	// original -> coreswitch:transmit-delay
	TransmitDelay uint16 `mapstructure:"transmit-delay" json:"transmit-delay,omitempty"`
}

func (lhs *OspfIp) Equal(rhs *OspfIp) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.AuthenticationKey != rhs.AuthenticationKey {
		return false
	}
	if lhs.Cost != rhs.Cost {
		return false
	}
	if lhs.DeadInterval != rhs.DeadInterval {
		return false
	}
	if lhs.HelloInterval != rhs.HelloInterval {
		return false
	}
	if lhs.Priority != rhs.Priority {
		return false
	}
	if lhs.RetransmitInterval != rhs.RetransmitInterval {
		return false
	}
	if lhs.TransmitDelay != rhs.TransmitDelay {
		return false
	}
	return true
}

//struct for container coreswitch:ip
type Ip struct {
	// original -> coreswitch:ospf
	OspfIp OspfIp `mapstructure:"ospf" json:"ospf,omitempty"`
}

func (lhs *Ip) Equal(rhs *Ip) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.OspfIp.Equal(&(rhs.OspfIp)) {
		return false
	}
	return true
}

//struct for container coreswitch:interface
type InterfaceIp struct {
	// original -> coreswitch:name
	Name string `mapstructure:"name" json:"name,omitempty"`
	// original -> coreswitch:ip
	Ip Ip `mapstructure:"ip" json:"ip,omitempty"`
}

func (lhs *InterfaceIp) Equal(rhs *InterfaceIp) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Name != rhs.Name {
		return false
	}
	if !lhs.Ip.Equal(&(rhs.Ip)) {
		return false
	}
	return true
}

//struct for container coreswitch:ospf-if-param
type OspfIfParam struct {
	// original -> coreswitch:interfaces
	InterfaceIps []InterfaceIp `mapstructure:"interfaces" json:"interfaces,omitempty"`
}

func (lhs *OspfIfParam) Equal(rhs *OspfIfParam) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if len(lhs.InterfaceIps) != len(rhs.InterfaceIps) {
		return false
	}
	{
		lmap := make(map[string]*InterfaceIp)
		for i, l := range lhs.InterfaceIps {
			lmap[mapkey(i, string(l.Name))] = &lhs.InterfaceIps[i]
		}
		for i, r := range rhs.InterfaceIps {
			if l, y := lmap[mapkey(i, string(r.Name))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	return true
}
